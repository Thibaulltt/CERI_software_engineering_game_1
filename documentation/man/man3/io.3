.TH "io" 3 "Wed Apr 26 2017" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
io \- Cet espace sera un espace permettant de définir un buffer custom pour les input, ainsi que de pouvoir afficher tout ce que l'on souhaite\&.  

.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBChangeTerminal\fP (bool Ech=0)"
.br
.RI "Changement des paramètres du terminal\&. "
.ti -1c
.RI "void \fBResetTerminal\fP ()"
.br
.RI "Remet le terminal à zero\&. "
.ti -1c
.RI "char \fBde\fP ()"
.br
.RI "Input\&. "
.ti -1c
.RI "void \fBremoveLastChar\fP (std::stringstream &i)"
.br
.RI "Enlève le dernier caractère d'un stringstream\&. "
.ti -1c
.RI "std::string \fBlong_input\fP ()"
.br
.RI "Long input\&. "
.ti -1c
.RI "int \fBgetTerminalWidth\fP ()"
.br
.RI "Retourne la largeur du terminal\&. "
.ti -1c
.RI "int \fBgetTerminalHeight\fP ()"
.br
.RI "Retourne la hauteur du terminal\&. "
.ti -1c
.RI "void \fBbienvenue\fP ()"
.br
.RI "Message d'accueil\&. "
.ti -1c
.RI "bool \fBcheckInput\fP (int x)"
.br
.RI "Vérifie que l'user entre des entier\&. "
.ti -1c
.RI "\fBcompetence\fP \fBcreateCompetence\fP ()"
.br
.RI "Creer une competence\&. "
.ti -1c
.RI "\fBcompetence\fP \fBcreateCompetenceMonstre\fP ()"
.br
.RI "Créer une compétence pour monstre (sans mana) "
.ti -1c
.RI "\fBmonstre\fP \fBcreateMonstre\fP ()"
.br
.RI "Créer un monstre\&. "
.ti -1c
.RI "std::vector< \fBcompetence\fP > \fBloadCompetenceFromFile\fP (std::string nomFichier, int numLigne)"
.br
.RI "Récupérer les compétences d'un monstre dans le \&.txt\&. "
.ti -1c
.RI "void \fBclearScreen\fP ()"
.br
.RI "Efface l'écran\&. "
.ti -1c
.RI "void \fBafficherCarte\fP (\fBCarte\fP &, \fBpersonnage\fP &, int)"
.br
.RI "Affichage de la carte\&. "
.ti -1c
.RI "void \fBafficherMouvements\fP ()"
.br
.ti -1c
.RI "void \fBafficherMouvements\fP (std::string)"
.br
.ti -1c
.RI "int \fBtaille_str\fP (std::string)"
.br
.RI "Compte la taille d'une string mieux que la fonction std::string::size(), car elle ne compte pas les accents comme deux caractères\&. "
.ti -1c
.RI "void \fBcheckTerminalSize\fP ()"
.br
.ti -1c
.RI "std::vector< \fBCarte\fP > \fBloadAllCarteFromFile\fP (std::string nomFichier)"
.br
.RI "Récupérer les cartes dans le \&.txt\&. "
.ti -1c
.RI "template<typename T > void \fBafficher\fP (T object)"
.br
.RI "Affichage d'objet\&. "
.ti -1c
.RI "template<typename T > void \fBliste_elements\fP (std::vector< T > vect_element)"
.br
.RI "Affichage d'un ensemble d'objets\&. "
.ti -1c
.RI "template<typename T > T \fBchoix_unique_element\fP (std::vector< T > vect_element)"
.br
.RI "Choix d'un élément unique\&. "
.ti -1c
.RI "template<typename T > std::vector< T > \fBloadAllEntiteFromFile\fP (T temp, std::string nomFichier)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "int \fBTermWidth\fP"
.br
.RI "Variable retennant la valeur de la largeur de la fenêtre du terminal\&. Elle permet de réduire le nombre de calculs à faire (étant donné que cette valeur est obtenue avec l'ouverture d'un fichier, son calcul prends donc quelques temps)\&. "
.ti -1c
.RI "int \fBTermHeight\fP"
.br
.RI "Variable retennant la valeur de la hauteur de la fenêtre du terminal\&. Elle permet de réduire le nombre de calculs à faire (étant donné que cette valeur est obtenue avec l'ouverture d'un fichier, son calcul prends donc quelques temps)\&. "
.ti -1c
.RI "std::string \fBBLANK\fP"
.br
.RI "Chaîne de caractères permettant de remettre à zéro la couleur du texte\&. "
.ti -1c
.RI "std::string \fBRED\fP"
.br
.RI "Chaîne de caractères permettant de rendre le texte affiché de couleur rouge\&. "
.ti -1c
.RI "std::string \fBGREEN\fP"
.br
.RI "Chaîne de caractères permettant de rendre le texte affiché de couleur verte\&. "
.ti -1c
.RI "std::string \fBYELLOW\fP"
.br
.RI "Chaîne de caractères permettant de rendre le texte affiché de couleur jaune\&. "
.ti -1c
.RI "std::string \fBBLUE\fP"
.br
.RI "Chaîne de caractères permettant de rendre le texte affiché de couleur bleue\&. "
.ti -1c
.RI "std::string \fBMAGENTA\fP"
.br
.RI "Chaîne de caractères permettant de rendre le texte affiché de couleur magenta\&. "
.ti -1c
.RI "int \fBmapPositionX\fP"
.br
.RI "Variable permettant de retenir à partir de quelle coordonnée 'x' la carte est affichée (si la carte est plus grande que la fenêtre de terminal, cette valeur ne sera pas toujours à 0 \&.\&.\&.) "
.ti -1c
.RI "int \fBmapPositiony\fP"
.br
.RI "Variable permettant de retenir à partir de quelle coordonnée 'y' la carte est affichée (si la carte est plus grande que la fenêtre de terminal, cette valeur ne sera pas toujours à 0 \&.\&.\&.) "
.ti -1c
.RI "int \fBinteractionsOverlayX\fP"
.br
.RI "Stocke la position (x) de l'affichage de l'overlay des actions\&. Nous n'avons pas besoin du Y car l'overlay prends toute la largeur quoi qu'il arrive\&. "
.ti -1c
.RI "std::pair< int, int > \fBcurrentPlayerPosition\fP"
.br
.RI "Paire de valeurs (std::pair) gardant la position actuelle du joueur dans\&. "
.in -1c
.SH "Detailed Description"
.PP 
Cet espace sera un espace permettant de définir un buffer custom pour les input, ainsi que de pouvoir afficher tout ce que l'on souhaite\&. 
.SH "Function Documentation"
.PP 
.SS "template<typename T > void io::afficher (T object)"

.PP
Affichage d'objet\&. Affiche le nom et la description d'un objet\&. 
.PP
\fBParameters:\fP
.RS 4
\fIobject\fP Objet à afficher\&. 
.RE
.PP

.SS "void io::afficherCarte (\fBCarte\fP &, \fBpersonnage\fP &, int)"

.PP
Affichage de la carte\&. 
.SS "void io::afficherMouvements ()"

.SS "void io::afficherMouvements (std::string)"

.SS "void io::bienvenue ()"

.PP
Message d'accueil\&. Affiche un message de bienvenue\&. 
.SS "void io::ChangeTerminal (bool Ech = \fC0\fP)"

.PP
Changement des paramètres du terminal\&. Permet de changer le mode d'entrée de stdin du terminal\&. Les paramètres présents auparavant sont sauvegardés\&. 
.PP
\fBParameters:\fP
.RS 4
\fIEch\fP Détermine si on veut que l'entrée utilisateur soit affichée ou pas\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBde()\fP, \fBlong_input()\fP 
.RE
.PP

.SS "bool io::checkInput (int x)"

.PP
Vérifie que l'user entre des entier\&. Cette fonction vérifie que l'entrée utilisateur est bien un entier\&.
.PP
Mode opératoire :
.IP "\(bu" 2
Vérification du failbit de l'entrée utilisateur (std::cin::failbit)
.IP "  1." 6
Vidage du buffer
.IP "  2." 6
Ignore 256 caractères ou jusqu'a \fC
.br
\fP
.IP "  3." 6
Affichage d'un message d'erreur d'entrée utilisateur\&.
.IP "  4." 6
Retourne faux
.PP

.IP "\(bu" 2
Sinon retourne vrai 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP on sait pas ce qu'il fait là, mais il est là\&. 
.RE
.PP

.PP

.SS "void io::checkTerminalSize ()"

.SS "template<typename T > T io::choix_unique_element (std::vector< T > vect_element)"

.PP
Choix d'un élément unique\&. Fonction qui prend un vecteur d'éléments en entrée ainsi qu'un booléen, et affiche puis renvoie l'élément choisi\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvect_element\fP Vecteur de l'élément à choisir\&. 
.br
\fIneed_desc\fP Nécessité de description ou non\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
L'élement choisi\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBliste_elements()\fP, \fBafficher()\fP 
.RE
.PP

.SS "void io::clearScreen ()"

.PP
Efface l'écran\&. 
.SS "\fBcompetence\fP io::createCompetence ()"

.PP
Creer une competence\&. Cette fonction permet de créer rapidement une compétence pour pouvoir l'utiliser facilement après\&.
.PP
Mode opératoire :
.IP "\(bu" 2
On crée les variables qui vont tenir les infos rentrées (skillName, skillDamage, skillManaCost)
.IP "\(bu" 2
On rentre 
.PP

.SS "\fBcompetence\fP io::createCompetenceMonstre ()"

.PP
Créer une compétence pour monstre (sans mana) 
.SS "\fBmonstre\fP io::createMonstre ()"

.PP
Créer un monstre\&. 
.SS "char io::de ()"

.PP
Input\&. Gestion des entrées utilisateur, ne prends qu'un seul caractère à la fois\&.
.PP
Voici son mode opératoire :
.IP "1." 4
On crée une variable (char)
.IP "2." 4
On change la façon dont le terminal gère l'entrée utilisateur avec \fBChangeTerminal()\fP
.IP "3." 4
On utilise la fonction std::getchar() (qui ne prends maintenant qu'un seul caractère sans avoir besoin d'appuyer sur entrée, grâce à \fBChangeTerminal()\fP)
.IP "4." 4
On remets les paramètres du terminal comme avant avec \fBResetTerminal()\fP
.IP "5." 4
On retourne l'entrée utilisateur 
.PP
\fBSee also:\fP
.RS 4
\fBChangeTerminal()\fP; \fBResetTerminal()\fP; \fBlong_input()\fP 
.RE
.PP

.PP

.SS "int io::getTerminalHeight ()"

.PP
Retourne la hauteur du terminal\&. 
.SS "int io::getTerminalWidth ()"

.PP
Retourne la largeur du terminal\&. 
.SS "template<typename T > void io::liste_elements (std::vector< T > vect_element)"

.PP
Affichage d'un ensemble d'objets\&. Parcourt le vecteur de stockage des objets chargés, et les affiche\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvect_element\fP Vecteur d'éléments\&. 
.br
\fIneed_desc\fP description ou non\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBafficher()\fP 
.RE
.PP

.SS "std::vector<\fBCarte\fP> io::loadAllCarteFromFile (std::string nomFichier)"

.PP
Récupérer les cartes dans le \&.txt\&. 
.SS "template<typename T > std::vector<T> io::loadAllEntiteFromFile (T temp, std::string nomFichier)"

.SS "std::vector<\fBcompetence\fP> io::loadCompetenceFromFile (std::string nomFichier, int numLigne)"

.PP
Récupérer les compétences d'un monstre dans le \&.txt\&. 
.SS "std::string io::long_input ()"

.PP
Long input\&. magic\&.gif 
.SS "void io::removeLastChar (std::stringstream & i)"

.PP
Enlève le dernier caractère d'un stringstream\&. Le but de cette fonction est d'enlever le dernier caractère d'un flux de caractères (std::stringstream) étant donné que le C++ ne propose pas de fonction par défaut pour cette fonctionnalité\&.
.PP
Voici son mode opératoire :
.IP "1." 4
On prends tout le contenu du stringstream et on le met dans une chaîne de caractères (std::string)
.IP "2." 4
Si la chaîne de caractère contient au moins 1 caractère :
.IP "  1." 6
On enlève le dernier caractère affiché sur stdout (en déplacant le curseur vers la droite après avoir affiché un espace)
.IP "  2." 6
Alors on utilise la fonction std::string::erase(std::string::iterator) pour enlever le dernier caractère
.IP "  3." 6
On remplace le contenu du flux de caractère par du vide
.IP "  4." 6
On remet la chaîne de caractère coupée dans le flux\&.
.PP

.PP
.PP
\fBPrecondition:\fP
.RS 4
La fonction recevra un stringstream d'entrée utilisateur\&. Son but est d'enlever le dernier caractère entré (cette fonction est appelée dans \fBlong_input()\fP dans une condition si le caractère rentré est 127, aussi connu sous le nom de DEL ASCII)\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
La fonction ne retourne rien, car le seul argument est passé \fBpar argument\fP et est donc automatiquement modifié\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIi\fP C'est un flux de caractères (std::stringstream) à partir duquel il faudra enlever le dernier caractère\&. 
.RE
.PP

.SS "void io::ResetTerminal ()"

.PP
Remet le terminal à zero\&. 
.SS "int io::taille_str (std::string)"

.PP
Compte la taille d'une string mieux que la fonction std::string::size(), car elle ne compte pas les accents comme deux caractères\&. 
.SH "Variable Documentation"
.PP 
.SS "std::string io::BLANK"

.PP
Chaîne de caractères permettant de remettre à zéro la couleur du texte\&. 
.SS "std::string io::BLUE"

.PP
Chaîne de caractères permettant de rendre le texte affiché de couleur bleue\&. 
.SS "std::pair<int,int> io::currentPlayerPosition"

.PP
Paire de valeurs (std::pair) gardant la position actuelle du joueur dans\&. 
.SS "std::string io::GREEN"

.PP
Chaîne de caractères permettant de rendre le texte affiché de couleur verte\&. 
.SS "int io::interactionsOverlayX"

.PP
Stocke la position (x) de l'affichage de l'overlay des actions\&. Nous n'avons pas besoin du Y car l'overlay prends toute la largeur quoi qu'il arrive\&. 
.SS "std::string io::MAGENTA"

.PP
Chaîne de caractères permettant de rendre le texte affiché de couleur magenta\&. 
.SS "int io::mapPositionX"

.PP
Variable permettant de retenir à partir de quelle coordonnée 'x' la carte est affichée (si la carte est plus grande que la fenêtre de terminal, cette valeur ne sera pas toujours à 0 \&.\&.\&.) 
.SS "int io::mapPositiony"

.PP
Variable permettant de retenir à partir de quelle coordonnée 'y' la carte est affichée (si la carte est plus grande que la fenêtre de terminal, cette valeur ne sera pas toujours à 0 \&.\&.\&.) 
.SS "std::string io::RED"

.PP
Chaîne de caractères permettant de rendre le texte affiché de couleur rouge\&. 
.SS "int io::TermHeight"

.PP
Variable retennant la valeur de la hauteur de la fenêtre du terminal\&. Elle permet de réduire le nombre de calculs à faire (étant donné que cette valeur est obtenue avec l'ouverture d'un fichier, son calcul prends donc quelques temps)\&. 
.SS "int io::TermWidth"

.PP
Variable retennant la valeur de la largeur de la fenêtre du terminal\&. Elle permet de réduire le nombre de calculs à faire (étant donné que cette valeur est obtenue avec l'ouverture d'un fichier, son calcul prends donc quelques temps)\&. 
.SS "std::string io::YELLOW"

.PP
Chaîne de caractères permettant de rendre le texte affiché de couleur jaune\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
