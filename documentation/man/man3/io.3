.TH "io" 3 "Fri May 5 2017" "The Game" \" -*- nroff -*-
.ad l
.nh
.SH NAME
io \- Cet espace sera un espace permettant de définir un buffer custom pour les input, ainsi que de pouvoir afficher tout ce que l'on souhaite\&.  

.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBChangeTerminal\fP (bool Ech=0)"
.br
.RI "Changement des paramètres du terminal\&. "
.ti -1c
.RI "void \fBResetTerminal\fP ()"
.br
.RI "Remet le terminal à zero\&. "
.ti -1c
.RI "int \fBgetTerminalWidth\fP ()"
.br
.RI "Retourne la largeur du terminal\&. "
.ti -1c
.RI "int \fBgetTerminalHeight\fP ()"
.br
.RI "Retourne la hauteur du terminal\&. "
.ti -1c
.RI "void \fBclearScreen\fP ()"
.br
.RI "Efface l'écran\&. "
.ti -1c
.RI "void \fBcheckTerminalSize\fP ()"
.br
.RI "Vérifie la taille du terminal\&. "
.ti -1c
.RI "char \fBde\fP ()"
.br
.RI "Input\&. "
.ti -1c
.RI "std::string \fBlong_input\fP ()"
.br
.RI "Entrée utilisateur contenant plus d'un caractère\&. "
.ti -1c
.RI "void \fBafficherCarte\fP (\fBCarte\fP &, int, bool reset=1)"
.br
.RI "Affichage de la carte\&. "
.ti -1c
.RI "void \fBupdateMap\fP (\fBCarte\fP &jeu_carte, std::pair< int, int > newPlayerPos)"
.br
.RI "Met à jour l'affichage de la carte\&. "
.ti -1c
.RI "void \fBbienvenue\fP ()"
.br
.RI "Message d'accueil\&. "
.ti -1c
.RI "void \fBafficherMouvements\fP ()"
.br
.RI "Fonction permettant d'afficher un overlay sur la carte\&. "
.ti -1c
.RI "void \fBafficherMouvements\fP (std::string erreur_deplacement)"
.br
.RI "Fonction permettant d'afficher un overlay sur la carte\&. "
.ti -1c
.RI "void \fBafficherMouvements\fP (std::string deplacements_possibles, std::string erreur_deplacement)"
.br
.RI "Fonction permettant d'afficher un overlay sur la carte\&. "
.ti -1c
.RI "void \fBafficherMouvements\fP (std::string message, std::string deplacements_possibles, std::string erreur_deplacement)"
.br
.RI "Fonction permettant d'afficher un overlay sur la carte\&. "
.ti -1c
.RI "void \fBupdateMessage\fP (std::string s, int pos)"
.br
.ti -1c
.RI "void \fBremoveLastChar\fP (std::stringstream &i)"
.br
.RI "Enlève le dernier caractère d'un stringstream\&. "
.ti -1c
.RI "bool \fBcheckInput\fP (int x)"
.br
.RI "Vérifie que l'user entre des entiers\&. "
.ti -1c
.RI "bool \fBcheckSeparatorEntite\fP (std::string uneLigne)"
.br
.RI "Verifie qu'une ligne est correcte dans un fichier texte d'entités (bon nombre de séparateurs) + //! Créer une competence\&. "
.ti -1c
.RI "bool \fBcheckSeparatorSkill\fP (std::string nomFichier, int numLigne)"
.br
.RI "Verifie qu'un champ compétences est correct dans un fichier texte d'entités (bon nombre de séparateurs) "
.ti -1c
.RI "int \fBtaille_str\fP (std::string)"
.br
.RI "Compte la taille d'une string mieux que la fonction std::string::size(), car elle ne compte pas les accents comme deux caractères\&. "
.ti -1c
.RI "void \fBsetPlayerPosition\fP (int, int)"
.br
.ti -1c
.RI "int \fBTo_int\fP (std::string input)"
.br
.RI "Convertit un string en int\&. "
.ti -1c
.RI "template<typename T > void \fBafficher\fP (T object)"
.br
.RI "Affichage d'objet\&. "
.ti -1c
.RI "template<typename T > void \fBliste_elements\fP (std::vector< T > vect_element)"
.br
.RI "Affichage d'un ensemble d'objets\&. "
.ti -1c
.RI "template<typename T > void \fBchoix_unique_element\fP (T &element, std::vector< T > vect_element, bool combat, bool aff=1)"
.br
.RI "Choix d'un élément unique\&. "
.ti -1c
.RI "void \fBaff_combat\fP (std::vector< \fBentite\fP > vect_entite)"
.br
.RI "Affichage des entités du combat\&. "
.ti -1c
.RI "std::vector< \fBcompetence\fP > \fBloadCompetenceFromFile\fP (std::string nomFichier, int numLigne)"
.br
.RI "Chargement des compétences\&. "
.ti -1c
.RI "std::vector< \fBCarte\fP > \fBloadAllCarteFromFile\fP (std::string nomFichier)"
.br
.RI "Chargement des cartes\&. "
.ti -1c
.RI "template<typename T > std::vector< T > \fBloadAllEntiteFromFile\fP (T temp, std::string nomFichier)"
.br
.RI "Chargement des entités\&. "
.ti -1c
.RI "template<typename T > std::string \fBtoString\fP (const T &valeur)"
.br
.ti -1c
.RI "bool \fBinputSepCheck\fP (std::string input)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "int \fBTermWidth\fP"
.br
.RI "Variable retennant la valeur de la largeur de la fenêtre du terminal\&. Elle permet de réduire le nombre de calculs à faire (étant donné que cette valeur est obtenue avec l'ouverture d'un fichier, son calcul prends donc quelques temps)\&. "
.ti -1c
.RI "int \fBTermHeight\fP"
.br
.RI "Variable retennant la valeur de la hauteur de la fenêtre du terminal\&. Elle permet de réduire le nombre de calculs à faire (étant donné que cette valeur est obtenue avec l'ouverture d'un fichier, son calcul prends donc quelques temps)\&. "
.ti -1c
.RI "std::string \fBBLANK\fP"
.br
.RI "Chaîne de caractères permettant de remettre à zéro la couleur du texte\&. "
.ti -1c
.RI "std::string \fBRED\fP"
.br
.RI "Chaîne de caractères permettant de rendre le texte affiché de couleur rouge\&. "
.ti -1c
.RI "std::string \fBGREEN\fP"
.br
.RI "Chaîne de caractères permettant de rendre le texte affiché de couleur verte\&. "
.ti -1c
.RI "std::string \fBYELLOW\fP"
.br
.RI "Chaîne de caractères permettant de rendre le texte affiché de couleur jaune\&. "
.ti -1c
.RI "std::string \fBBLUE\fP"
.br
.RI "Chaîne de caractères permettant de rendre le texte affiché de couleur bleue\&. "
.ti -1c
.RI "std::string \fBMAGENTA\fP"
.br
.RI "Chaîne de caractères permettant de rendre le texte affiché de couleur magenta\&. "
.ti -1c
.RI "int \fBmapPositionX\fP"
.br
.RI "Variable permettant de retenir à partir de quelle coordonnée 'x' la carte est affichée (si la carte est plus grande que la fenêtre de terminal, cette valeur ne sera pas toujours à 0 \&.\&.\&.) "
.ti -1c
.RI "int \fBmapPositiony\fP"
.br
.RI "Variable permettant de retenir à partir de quelle coordonnée 'y' la carte est affichée (si la carte est plus grande que la fenêtre de terminal, cette valeur ne sera pas toujours à 0 \&.\&.\&.) "
.ti -1c
.RI "int \fBinteractionsOverlayY\fP"
.br
.RI "Stocke la position (x) de l'affichage de l'overlay des actions\&. Nous n'avons pas besoin du Y car l'overlay prends toute la largeur quoi qu'il arrive\&. "
.ti -1c
.RI "std::pair< int, int > \fBcurrentPlayerPosition\fP"
.br
.RI "Paire de valeurs (std::pair) gardant la position actuelle du joueur dans\&. "
.in -1c
.SH "Detailed Description"
.PP 
Cet espace sera un espace permettant de définir un buffer custom pour les input, ainsi que de pouvoir afficher tout ce que l'on souhaite\&. 
.SH "Function Documentation"
.PP 
.SS "void io::aff_combat (std::vector< \fBentite\fP > vect_entite)"

.PP
Affichage des entités du combat\&. Parcourt le vecteur d'entités, affiche les personnages\&. Parcourt de nouveau le vecteur, affiche les monstres\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvect_entité\fP Le vecteur d'entités à afficher\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
afficher_combat() 
.RE
.PP

.SS "template<typename T > void io::afficher (T object)"

.PP
Affichage d'objet\&. Affiche le nom et la description d'un objet\&.
.PP
\fBParameters:\fP
.RS 4
\fIobject\fP Objet à afficher\&. 
.RE
.PP

.SS "void io::afficherCarte (\fBCarte\fP &, int, bool reset = \fC1\fP)"

.PP
Affichage de la carte\&. 
.SS "void io::afficherMouvements ()"

.PP
Fonction permettant d'afficher un overlay sur la carte\&. Fonction permettant d'afficher un overlay sur la carte, montrant au joueur dans quelles directions il peut aller\&. Ne fait qu'appeller \fBafficherMouvements(std::string deplacements_possibles, std::string erreur_deplacement)\fP
.PP
\fBSee also:\fP
.RS 4
\fBafficherMouvements(std::string erreur_deplacement)\fP & \fBafficherMouvements(std::string deplacements_possibles, std::string erreur_deplacement)\fP 
.RE
.PP

.SS "void io::afficherMouvements (std::string erreur_deplacement)"

.PP
Fonction permettant d'afficher un overlay sur la carte\&. Fonction permettant d'afficher un overlay sur la carte, montrant au joueur dans quelles directions il peut aller\&. Il affiche aussi un message d'erreur si demandé\&. Ne fait qu'appeller \fBafficherMouvements(std::string deplacements_possibles, std::string erreur_deplacement)\fP
.PP
\fBSee also:\fP
.RS 4
\fBafficherMouvements()\fP & \fBafficherMouvements(std::string deplacements_possibles, std::string erreur_deplacement)\fP 
.RE
.PP

.SS "void io::afficherMouvements (std::string deplacements_possibles, std::string erreur_deplacement)"

.PP
Fonction permettant d'afficher un overlay sur la carte\&. Fonction permettant d'afficher un overlay sur la carte, montrant au joueur dans quelles directions il peut aller\&. Ne fait qu'appeller \fBafficherMouvements(std::string deplacements_possibles, std::string erreur_deplacement)\fP
.PP
\fBSee also:\fP
.RS 4
\fBafficherMouvements()\fP & \fBafficherMouvements(std::string erreur_deplacement)\fP 
.RE
.PP

.SS "void io::afficherMouvements (std::string message, std::string deplacements_possibles, std::string erreur_deplacement)"

.PP
Fonction permettant d'afficher un overlay sur la carte\&. Fonction permettant d'afficher un overlay sur la carte, montrant au joueur dans quelles directions il peut aller\&. Ne fait qu'appeller \fBafficherMouvements(std::string deplacements_possibles, std::string erreur_deplacement)\fP
.PP
\fBSee also:\fP
.RS 4
\fBafficherMouvements()\fP & \fBafficherMouvements(std::string erreur_deplacement)\fP & \fBafficherMouvements(std::string deplacements_possibles, std::string erreur_deplacement)\fP 
.RE
.PP

.SS "void io::bienvenue ()"

.PP
Message d'accueil\&. Affiche un message de bienvenue\&. 
.SS "void io::ChangeTerminal (bool Ech = \fC0\fP)"

.PP
Changement des paramètres du terminal\&. Permet de changer le mode d'entrée de stdin du terminal\&. Les paramètres présents auparavant sont sauvegardés\&.
.PP
\fBParameters:\fP
.RS 4
\fIEch\fP Détermine si on veut que l'entrée utilisateur soit affichée ou pas\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBde()\fP, \fBlong_input()\fP 
.RE
.PP

.SS "bool io::checkInput (int x)"

.PP
Vérifie que l'user entre des entiers\&. Cette fonction vérifie que l'entrée utilisateur est bien un entier\&. Mode opératoire :
.IP "\(bu" 2
Vérification du failbit de l'entrée utilisateur (std::cin::failbit)
.IP "  1." 6
Vidage du buffer
.IP "  2." 6
Ignore 256 caractères ou jusqu'a \fC
.br
\fP
.IP "  3." 6
Affichage d'un message d'erreur d'entrée utilisateur\&.
.IP "  4." 6
Retourne faux
.PP

.IP "\(bu" 2
Sinon retourne vrai
.PP
.PP
\fBParameters:\fP
.RS 4
\fIx\fP on sait pas ce qu'il fait là, mais il est là\&. 
.RE
.PP

.SS "bool io::checkSeparatorEntite (std::string uneLigne)"

.PP
Verifie qu'une ligne est correcte dans un fichier texte d'entités (bon nombre de séparateurs) + //! Créer une competence\&. Cette fonction permet de vérifier qu'une ligne contient bien le bon nombre de séparateurs pour éviter les erreurs dans le chargement d'une entité Mode opératoire:
.IP "\(bu" 2
Parcours de toute la string passée en paramétre
.IP "\(bu" 2
A chaque séparateur trouvé, on ajoute 1 aux compteurs
.IP "\(bu" 2
Si le nombre de séparateurs correspond au nombre défini, on retourne true
.PP
.PP
\fBParameters:\fP
.RS 4
\fIuneLigne\fP Ligne à vérifier 
.RE
.PP

.SS "bool io::checkSeparatorSkill (std::string nomFichier, int numLigne)"

.PP
Verifie qu'un champ compétences est correct dans un fichier texte d'entités (bon nombre de séparateurs) Cette fonction permet de vérifier qu'un champ compétences d'une ligne contient bien le bon nombre de séparateurs pour éviter les erreurs dans le chargement d'une entité Mode opératoire:
.IP "\(bu" 2
Recherche de la ligne dans le fichier
.IP "\(bu" 2
Parcours de toute la ligne
.IP "\(bu" 2
A chaque séparateur trouvé, on ajoute 1 aux compteurs
.IP "\(bu" 2
Si le nombre de séparateurs correspond au nombre défini, on retourne true
.PP
.PP
\fBParameters:\fP
.RS 4
\fInomFichier\fP Le nom du fichier \&.txt dans lequel on fait la vérification 
.br
\fInumLigne\fP Le numéro de la ligne à vérifier 
.RE
.PP

.SS "void io::checkTerminalSize ()"

.PP
Vérifie la taille du terminal\&. 
.SS "template<typename T > void io::choix_unique_element (T & element, std::vector< T > vect_element, bool combat, bool aff = \fC1\fP)"

.PP
Choix d'un élément unique\&. Fonction qui prend un élément, un vecteur d'éléments ainsi qu'un booléen en entrée, et affiche les caractéristiques assignées à l'élément\&.
.PP
\fBParameters:\fP
.RS 4
\fIelement\fP Elément dont les caractéristiques doivent être établies\&. 
.br
\fIvect_element\fP Vecteur de l'élément à choisir\&. 
.br
\fIcombat\fP Situation de combat ou non\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
L'élement choisi\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBliste_elements()\fP, \fBafficher()\fP, afficher_detail() 
.RE
.PP

.SS "void io::clearScreen ()"

.PP
Efface l'écran\&. 
.SS "char io::de ()"

.PP
Input\&. Gestion des entrées utilisateur, ne prends qu'un seul caractère à la fois\&.
.PP
Voici son mode opératoire :
.IP "1." 4
On crée une variable (char)
.IP "2." 4
On change la façon dont le terminal gère l'entrée utilisateur avec \fBChangeTerminal()\fP
.IP "3." 4
On utilise la fonction std::getchar() (qui ne prends maintenant qu'un seul caractère sans avoir besoin d'appuyer sur entrée, grâce à \fBChangeTerminal()\fP)
.IP "4." 4
On remets les paramètres du terminal comme avant avec \fBResetTerminal()\fP
.IP "5." 4
On retourne l'entrée utilisateur
.PP
.PP
\fBSee also:\fP
.RS 4
\fBChangeTerminal()\fP; \fBResetTerminal()\fP; \fBlong_input()\fP 
.RE
.PP

.SS "int io::getTerminalHeight ()"

.PP
Retourne la hauteur du terminal\&. 
.SS "int io::getTerminalWidth ()"

.PP
Retourne la largeur du terminal\&. 
.SS "bool io::inputSepCheck (std::string input)"

.SS "template<typename T > void io::liste_elements (std::vector< T > vect_element)"

.PP
Affichage d'un ensemble d'objets\&. Parcourt le vecteur de stockage des objets chargés, et les affiche\&.
.PP
\fBParameters:\fP
.RS 4
\fIvect_element\fP Vecteur d'éléments\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBafficher()\fP 
.RE
.PP

.SS "std::vector<\fBCarte\fP> io::loadAllCarteFromFile (std::string nomFichier)"

.PP
Chargement des cartes\&. Lit toutes les lignes d'un fichier, et remplit un vecteur avec des objets construits à partir des informations récupérées\&. 
.PP
\fBParameters:\fP
.RS 4
\fInomFichier\fP Le nom du fichier à partir duquel on lit les informations\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Un vecteur contenant les cartes créées\&. 
.RE
.PP

.SS "template<typename T > std::vector<T> io::loadAllEntiteFromFile (T temp, std::string nomFichier)"

.PP
Chargement des entités\&. Lit toutes les lignes d'un fichier, et remplit un vecteur avec des objets construits à partir des informations récupérées\&. 
.PP
\fBParameters:\fP
.RS 4
\fItemp\fP Objet dummy permettant au compilateur de comprendre de quel type d'objet il s'agit\&. 
.br
\fInomFichier\fP Le nom du fichier à partir duquel on lit les informations\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Un vecteur contenant les entités créées\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBloadCompetenceFromFile()\fP 
.RE
.PP

.SS "std::vector<\fBcompetence\fP> io::loadCompetenceFromFile (std::string nomFichier, int numLigne)"

.PP
Chargement des compétences\&. Lit une ligne d'un fichier, et remplit un vecteur avec des objets construits à partir des informations récupérées\&. 
.PP
\fBParameters:\fP
.RS 4
\fInomFichier\fP Le nom du fichier à partir duquel on lit les informations\&. 
.br
\fInumLigne\fP La ligne sur laquelle on recherche les informations\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Un vecteur contenant les compétences créées\&. 
.RE
.PP

.SS "std::string io::long_input ()"

.PP
Entrée utilisateur contenant plus d'un caractère\&. Mode opératoire :
.IP "\(bu" 2
Utilise les mêmes fonction de changement du terminal que \fC\fBde()\fP\fP (avec la seule différence que l'echo des caractères rentrés est activé), mais possède une boucle qui utilise \fCgetchar()\fP tant que le caractère entré est différent de la touche \fCENTREE\fP\&.
.IP "\(bu" 2
Enlève ensuite le dernier caractère (qui est un caractère \fCRETOUR_CHARIOT\fP+\fCNEWLINE\fP)\&.
.IP "  \(bu" 4
Si la longueur de la chaîne résultante est de 0, alors l'utilisateur n'a rien saisi, donc on lui redemande\&.
.IP "  \(bu" 4
Sinon, on renvoie l'entrée utilisateur\&. 
.PP

.PP

.SS "void io::removeLastChar (std::stringstream & i)"

.PP
Enlève le dernier caractère d'un stringstream\&. Le but de cette fonction est d'enlever le dernier caractère d'un flux de caractères (std::stringstream) étant donné que le C++ ne propose pas de fonction par défaut pour cette fonctionnalité\&. Voici son mode opératoire :
.IP "1." 4
On prends tout le contenu du stringstream et on le met dans une chaîne de caractères (std::string)
.IP "2." 4
Si la chaîne de caractère contient au moins 1 caractère :
.IP "  1." 6
On enlève le dernier caractère affiché sur stdout (en déplacant le curseur vers la droite après avoir affiché un espace)
.IP "  2." 6
Alors on utilise la fonction std::string::erase(std::string::iterator) pour enlever le dernier caractère
.IP "  3." 6
On remplace le contenu du flux de caractère par du vide
.IP "  4." 6
On remet la chaîne de caractère coupée dans le flux\&.
.PP

.PP
.PP
\fBPrecondition:\fP
.RS 4
La fonction recevra un stringstream d'entrée utilisateur\&. Son but est d'enlever le dernier caractère entré (cette fonction est appelée dans \fBlong_input()\fP dans une condition si le caractère rentré est 127, aussi connu sous le nom de DEL ASCII)\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
La fonction ne retourne rien, car le seul argument est passé \fBpar argument\fP et est donc automatiquement modifié\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIi\fP C'est un flux de caractères (std::stringstream) à partir duquel il faudra enlever le dernier caractère\&. 
.RE
.PP

.SS "void io::ResetTerminal ()"

.PP
Remet le terminal à zero\&. 
.SS "void io::setPlayerPosition (int, int)"

.SS "int io::taille_str (std::string)"

.PP
Compte la taille d'une string mieux que la fonction std::string::size(), car elle ne compte pas les accents comme deux caractères\&. 
.SS "int io::To_int (std::string input)"

.PP
Convertit un string en int\&. Renvoie 0 si l'input n'est pas convertible\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP String à convertir 
.RE
.PP
\fBReturns:\fP
.RS 4
Entier obtenu suite à la conversion 
.RE
.PP

.SS "template<typename T > std::string io::toString (const T & valeur)"

.SS "void io::updateMap (\fBCarte\fP & jeu_carte, std::pair< int, int > newPlayerPos)"

.PP
Met à jour l'affichage de la carte\&. 
.SS "void io::updateMessage (std::string s, int pos)"

.SH "Variable Documentation"
.PP 
.SS "std::string io::BLANK"

.PP
Chaîne de caractères permettant de remettre à zéro la couleur du texte\&. 
.SS "std::string io::BLUE"

.PP
Chaîne de caractères permettant de rendre le texte affiché de couleur bleue\&. 
.SS "std::pair<int,int> io::currentPlayerPosition"

.PP
Paire de valeurs (std::pair) gardant la position actuelle du joueur dans\&. 
.SS "std::string io::GREEN"

.PP
Chaîne de caractères permettant de rendre le texte affiché de couleur verte\&. 
.SS "int io::interactionsOverlayY"

.PP
Stocke la position (x) de l'affichage de l'overlay des actions\&. Nous n'avons pas besoin du Y car l'overlay prends toute la largeur quoi qu'il arrive\&. 
.SS "std::string io::MAGENTA"

.PP
Chaîne de caractères permettant de rendre le texte affiché de couleur magenta\&. 
.SS "int io::mapPositionX"

.PP
Variable permettant de retenir à partir de quelle coordonnée 'x' la carte est affichée (si la carte est plus grande que la fenêtre de terminal, cette valeur ne sera pas toujours à 0 \&.\&.\&.) 
.SS "int io::mapPositiony"

.PP
Variable permettant de retenir à partir de quelle coordonnée 'y' la carte est affichée (si la carte est plus grande que la fenêtre de terminal, cette valeur ne sera pas toujours à 0 \&.\&.\&.) 
.SS "std::string io::RED"

.PP
Chaîne de caractères permettant de rendre le texte affiché de couleur rouge\&. 
.SS "int io::TermHeight"

.PP
Variable retennant la valeur de la hauteur de la fenêtre du terminal\&. Elle permet de réduire le nombre de calculs à faire (étant donné que cette valeur est obtenue avec l'ouverture d'un fichier, son calcul prends donc quelques temps)\&. 
.SS "int io::TermWidth"

.PP
Variable retennant la valeur de la largeur de la fenêtre du terminal\&. Elle permet de réduire le nombre de calculs à faire (étant donné que cette valeur est obtenue avec l'ouverture d'un fichier, son calcul prends donc quelques temps)\&. 
.SS "std::string io::YELLOW"

.PP
Chaîne de caractères permettant de rendre le texte affiché de couleur jaune\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for The Game from the source code\&.
