.TH "jeu" 3 "Fri May 5 2017" "The Game" \" -*- nroff -*-
.ad l
.nh
.SH NAME
jeu \- Ceci sera la classe du jeu\&. Elle contient toutes les entités, la carte, ainsi que les fonctions nécessaires à la partie\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <fonctionsjeu\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBjeu\fP ()"
.br
.RI "Temporaire!! "
.ti -1c
.RI "\fB~jeu\fP ()"
.br
.RI "Destructeur par défaut\&. "
.ti -1c
.RI "\fBCarte\fP \fBgetCarte\fP ()"
.br
.RI "Getter de carte de jeu\&. "
.ti -1c
.RI "\fBpersonnage\fP \fBgetPerso\fP ()"
.br
.RI "Getter de personnage\&. "
.ti -1c
.RI "std::vector< \fBmonstre\fP > \fBgetMonstres\fP ()"
.br
.RI "Getter de vecteur de monstres\&. "
.ti -1c
.RI "int \fBgetNbMonstres\fP ()"
.br
.RI "Getter de nombre de monstres\&. "
.ti -1c
.RI "void \fBsetJeuCarte\fP (\fBCarte\fP jeu_map)"
.br
.RI "Setter de carte de jeu\&. "
.ti -1c
.RI "void \fBdeplacement\fP (int &result)"
.br
.RI "Fonction de déplacement du joueur sur la carte\&. "
.ti -1c
.RI "void \fBafficherJeu\fP (int &result)"
.br
.RI "Fonction permettant d'afficher la carte, puis de demander un déplacement au joueur\&. "
.ti -1c
.RI "std::string \fBgenererDeplacement\fP (std::vector< bool > &v)"
.br
.RI "Fonction permettant de générer les déplacements possibles à partir d'une case \fCi,j\fP du plateau de jeu\&. "
.ti -1c
.RI "std::string \fBgenererInputAccepte\fP (std::vector< bool > b)"
.br
.RI "Fonction permettant de générer une chaine d'entrées utilisateur acceptables pour le déplacement\&. "
.ti -1c
.RI "int \fBcombat\fP (std::string id_monstre)"
.br
.RI "Module de combat\&. "
.ti -1c
.RI "std::vector< \fBmonstre\fP >::iterator \fBcherche_monstre\fP (std::string id_monstre)"
.br
.RI "Recherche de monstre\&. "
.ti -1c
.RI "bool \fBchargement_entite\fP (std::vector< \fBentite\fP > &vect_entite, std::string id_monstre)"
.br
.RI "Chargement acteurs combat\&. "
.ti -1c
.RI "std::vector< int > \fBorga_entites\fP (std::vector< \fBentite\fP > &vect_entite)"
.br
.RI "Organisation entités\&. "
.ti -1c
.RI "\fBcompetence\fP \fBchoix_comp\fP (\fBentite\fP &indiv)"
.br
.RI "Choix compétence\&. "
.ti -1c
.RI "\fBentite\fP \fBchoix_target\fP (\fBcompetence\fP comp_util, \fBentite\fP &indiv, std::vector< \fBentite\fP > &vect_entite, std::vector< int > vect_p)"
.br
.RI "Choix cible\&. "
.ti -1c
.RI "int \fBappliquer_comp\fP (\fBentite\fP indiv, \fBentite\fP target, std::vector< \fBentite\fP > &vect_entite, \fBcompetence\fP comp_util, int &nb_players, int &nb_monsters)"
.br
.RI "Appliquer compétence\&. "
.ti -1c
.RI "void \fBquitGame\fP ()"
.br
.RI "Quitte le jeu, sans que l'utilisateur n'ai gagné ni perdu\&. "
.ti -1c
.RI "void \fBvictoireGame\fP ()"
.br
.RI "Affiche un message de victoire à l'utilisateur\&. "
.ti -1c
.RI "void \fBfailedGame\fP ()"
.br
.RI "Affiche un message de défait au joueur\&. "
.in -1c
.SH "Detailed Description"
.PP 
Ceci sera la classe du jeu\&. Elle contient toutes les entités, la carte, ainsi que les fonctions nécessaires à la partie\&. 

Cette classe contient les fonctions nécessaires au démarrage de la partie, au combat, ainsi que toutes les fonctions intermédiaires nécessaires au bon fonctionnement de celles-ci\&.
.PP
Inclut la librairie io\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "jeu::jeu ()"

.PP
Temporaire!! Constructeur par défaut sans argument\&.
.PP
Affichage d'un message de bienvenue\&. Choix du personnage\&. Choix de la carte\&. Chargement des monstres\&.
.PP
\fBSee also:\fP
.RS 4
perso(), carte(), \fBmonstre()\fP 
.RE
.PP

.SS "jeu::~jeu ()"

.PP
Destructeur par défaut\&. 
.SH "Member Function Documentation"
.PP 
.SS "void jeu::afficherJeu (int & result)"

.PP
Fonction permettant d'afficher la carte, puis de demander un déplacement au joueur\&. 
.PP
\fBNote:\fP
.RS 4
Cette fonction est là uniquement pour des fins de tests\&. La fonctionnalité qu'elle remplit sera remplacée par d'autres méthodes dans la fichier \fCtests/main\&.cpp\fP\&. 
.RE
.PP

.SS "int jeu::appliquer_comp (\fBentite\fP indiv, \fBentite\fP target, std::vector< \fBentite\fP > & vect_entite, \fBcompetence\fP comp_util, int & nb_players, int & nb_monsters)"

.PP
Appliquer compétence\&. Permet d'appliquer les effets de la compétence choisie sur la cible choisie\&. Si la cible meurt, décrémente le compteur de personnages/monstres vivants\&. Supprime les cibles mortes du vecteur d'entités\&. 
.PP
\fBParameters:\fP
.RS 4
\fItarget\fP Cible de la compétence\&. 
.br
\fIvect_entite\fP Le vecteur duquel on tire la cible de la compétence\&. 
.br
\fIcomp_util\fP La compétence à utiliser\&. 
.br
\fInb_players\fP Le nombre total de joueurs de la partie\&. 
.br
\fInb_monsters\fP Le nombre de monstres du combat en cours\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Un entier: 1 si tous les monstres sont morts, 0 si tous les joueurs sont morts, 2 sinon\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
enleverVie() 
.RE
.PP

.SS "bool jeu::chargement_entite (std::vector< \fBentite\fP > & vect_entite, std::string id_monstre)"

.PP
Chargement acteurs combat\&. Permet de charger tous les acteurs du combat dans un vecteur d'entités\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvect_entite\fP Vecteur où chercher le monstre\&. 
.br
\fIid_monstre\fP Identifiant du monstre à charger\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Chargement réussi ou non\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcherche_monstre()\fP 
.RE
.PP

.SS "std::vector<\fBmonstre\fP>::iterator jeu::cherche_monstre (std::string id_monstre)"

.PP
Recherche de monstre\&. Permet de trouver l'objet monstre correspondant à la string id trouvée sur une case\&. Si la valeur renvoyée correspond à la fin du vecteur, le monstre n'a pas été trouvé\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid_monstre\fP Identifiant du monstre à trouver\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Un itérateur correspondant à l'élément du vecteur de monstres concerné\&. 
.RE
.PP

.SS "\fBcompetence\fP jeu::choix_comp (\fBentite\fP & indiv)"

.PP
Choix compétence\&. Permet de sélectionner une compétence par input parmi une liste tirée d'un vecteur (spécifique à chaque entité) Vérifie la possibilité du lancer (niveau de mana)\&. Si l'entité est un monstre, le choix est aléatoire\&. 
.PP
\fBParameters:\fP
.RS 4
\fIindiv\fP L'entité qui joue actuellement\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Une compétence parmi les compétences utilisables\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBchoix_unique_element()\fP 
.RE
.PP

.SS "\fBentite\fP jeu::choix_target (\fBcompetence\fP comp_util, \fBentite\fP & indiv, std::vector< \fBentite\fP > & vect_entite, std::vector< int > vect_p)"

.PP
Choix cible\&. Permet de choisir une cible parmi une liste tirée d'un vecteur de cibles disponibles\&. Si l'entité est un monstre, le choix est aléatoire (uniquement parmi les cibles personnages)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcomp_util\fP La compétence à utiliser\&. 
.br
\fIindiv\fP L'entité qui joue actuellement\&. 
.br
\fIvect_entite\fP Le vecteur duquel on tire la cible de la compétence\&. 
.br
\fIvect_p\fP Vecteur permettant d'identifier les personnages parmi toutes les entités\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Une entité, cible de la compétence\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBchoix_unique_element()\fP 
.RE
.PP

.SS "int jeu::combat (std::string id_monstre)"

.PP
Module de combat\&. Permet de gérer le combat\&.
.IP "\(bu" 2
Charge les entités (personnages et monstres) contenus dans la case\&.
.IP "\(bu" 2
Identifie les personnages et leur nombre\&.
.IP "\(bu" 2
Identifie les monstres et leur nombre\&.
.IP "\(bu" 2
Pour chaque acteur, choix d'une compétence, puis d'une cible, puis application des effets\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid_monstre\fP Identifiant du monstre à combattre\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Un entier: 1 si la partie continue, 0 si elle se termine\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBchargement_entite()\fP, \fBorga_entites()\fP, \fBaff_combat()\fP, \fBchoix_comp()\fP, \fBchoix_target()\fP, \fBappliquer_comp()\fP 
.RE
.PP

.PP

.SS "void jeu::deplacement (int & result)"

.PP
Fonction de déplacement du joueur sur la carte\&. Cette fonction permet au joueur de se déplacer sur la carte, en tenant compte des obstacles présents sur ladite carte\&.
.PP
Mode opératoire :
.IP "\(bu" 2
Génère les déplacements possibles grâce à la fonction \fC\fBgenererDeplacement()\fP\fP ;
.IP "\(bu" 2
Génère les entrées utilisateur possibles grâce à la fonction \fC\fBgenererInputAccepte()\fP\fP ;
.IP "\(bu" 2
Va chercher la position actuelle du joueur, puis la stocke dans deux entiers (\fCx\fP et \fCy\fP, oui je sais ces noms sont très originaux) ;
.IP "\(bu" 2
Afficher les mouvements possibles au joueur grâce à la fonction \fC\fBafficherMouvements()\fP\fP ;
.IP "\(bu" 2
Demande à l'utilisateur où il souhaiterais aller grâce à la fonction \fC\fBde()\fP\fP
.IP "\(bu" 2
Si le joueur rentre un caractère non compris dans la liste des mouvements possibles :
.IP "  \(bu" 4
On ré-affiche les mouvements possibles avec \fC\fBafficherMouvements()\fP\fP, cette fois-ci avec un message d'erreur en plus\&.
.IP "  \(bu" 4
On re-demande son choix pour le mouvement grâce à la fonction \fC\fBde()\fP\fP
.PP

.IP "\(bu" 2
On change les coordonnées des entiers \fCx\fP et \fCy\fP en accord avec la demande de l'utilisateur dans un \fCswitch\fP\&.
.IP "\(bu" 2
On met à jour l'affichage de la carte grâce à la fonction \fC\fBupdateMap()\fP\fP 
.PP
\fBPostcondition:\fP
.RS 4
La position du joueur aura changé\&. La paire d'entiers \fCcurrentPlayerPosition\fP sera donc mise à jour (grâce à \fC\fBupdateMap()\fP\fP)\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBafficherMouvements()\fP, \fBgenererDeplacement()\fP, \fBgenererInputAccepte()\fP, \fBde()\fP & \fBio::updateMap()\fP 
.RE
.PP

.PP

.SS "void jeu::failedGame ()"

.PP
Affiche un message de défait au joueur\&. 
.SS "std::string jeu::genererDeplacement (std::vector< bool > & v)"

.PP
Fonction permettant de générer les déplacements possibles à partir d'une case \fCi,j\fP du plateau de jeu\&. Cette fonction permet de générer la chaîne de caractères qui affiche les déplacements disponibles au joueur à partir de la case où il se trouve\&. Mode opératoire :
.IP "\(bu" 2
On prends les coordonnées actuelles du joueur, que l'on met dans deux entiers créativement appelés \fCx\fP et \fCy\fP\&.
.IP "\(bu" 2
On prends la taille de la carte du jeu grâce à la fonction \fCcarte::getTaille()\fP\&. La taille du plateau nous sert à déterminer si une case existe, enlevant ainsi un peu de temps de calcul lors de l'analyse des cases voisines à celle où se trouve le joueur\&.
.IP "\(bu" 2
On crée une chaîne de caractères\&. Cette chaîne servira à stocker les déplacements possibles à afficher par la suite au joueur\&.
.IP "\(bu" 2
On vérifie les cases autour du joueur en vérifiant leurs indices et leur contenu (grâce à la fonction \fCcarte::caseAccessible()\fP)
.IP "\(bu" 2
Si la case au dessus du joueur est libre, alors :
.IP "  \(bu" 4
On ajoute \fCZ - Haut\fP à la chaîne de caractères
.IP "  \(bu" 4
On met à 1 le booléen permettant de savoir si la case est accessible ou non\&.
.PP

.IP "\(bu" 2
Si la case à la gauche du joueur est libre, alors :
.IP "  \(bu" 4
On ajoute \fCQ - Gauche\fP à la chaîne de caractères
.IP "  \(bu" 4
On met à 1 le booléen permettant de savoir si la case est accessible ou non\&.
.PP

.IP "\(bu" 2
Si la case en dessous du joueur est libre, alors :
.IP "  \(bu" 4
On ajoute \fCS - Bas\fP à la chaîne de caractères
.IP "  \(bu" 4
On met à 1 le booléen permettant de savoir si la case est accessible ou non\&.
.PP

.IP "\(bu" 2
Si la case à la droite du joueur est libre, alors :
.IP "  \(bu" 4
On ajoute \fCD - Droite\fP à la chaîne de caractères
.IP "  \(bu" 4
On met à 1 le booléen permettant de savoir si la case est accessible ou non\&.
.PP

.IP "\(bu" 2
On retourne la châine de caractères générée\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv\fP Vecteur de booléens (\fCstd::vector<bool>\fP) permettant de savoir quelles cases sont accessibles aux alentours de la case où se trouve le joueur\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Une châine de caractères à afficher au joueur pour qu'il puisse savoir où il peut aller\&. La chaine est définie par l'expression régulière suivante : \fC'|'+(' Z - Haut |')?+(' Q - Gauche |')?+(' S - Bas |')?+(' D - Droite |')?\fP 
.RE
.PP
\fBPostcondition:\fP
.RS 4
La fonction \fI\fBne change absolument rien\fP\fP au plateau, ni au jeu\&. Toutes les données générées pour l'analyse des voisins de la case ont une portée locale\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgenererInputAccepte()\fP, \fBdeplacement()\fP, carte::caseAccessible() & carte::getTaille() 
.RE
.PP

.PP

.SS "std::string jeu::genererInputAccepte (std::vector< bool > b)"

.PP
Fonction permettant de générer une chaine d'entrées utilisateur acceptables pour le déplacement\&. Cette fonction permet de générer la chaîne de caractères qui sera analysée pour accepter ou non un déplacement demandé par le joueur à partir de la case où il se trouve\&.
.PP
Mode opératoire :
.IP "\(bu" 2
Crée une chaîne de caractères (\fCstd::string\fP) qui contiendra les caractères acceptés lors de l'entrée utilisateur dans la fonction \fC\fBdeplacement()\fP\fP\&.
.IP "\(bu" 2
Lit le vecteur de booléens rempli dans la fonction \fC\fBgenererDeplacement()\fP\fP :
.IP "  \(bu" 4
Si le premier booléen est à 1 : on ajoute 'Zz' à la chaîne (l'utilisateur pourra donc appuyer sur 'Z' ou 'z' et se déplacer)
.IP "  \(bu" 4
Si le second booléen est à 1 : on ajoute 'Qq' à la chaîne (l'utilisateur pourra donc appuyer sur 'Q' ou 'q' et se déplacer)
.IP "  \(bu" 4
Si le troisième booléen est à 1 : on ajoute 'Ss' à la chaîne (l'utilisateur pourra donc appuyer sur 'S' ou 's' et se déplacer)
.IP "  \(bu" 4
Si le quatrième booléen est à 1 : on ajoute 'Dd' à la chaîne (l'utilisateur pourra donc appuyer sur 'D' ou 'd' et se déplacer)
.PP

.IP "\(bu" 2
Retourne la chaîne de caractères\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb\fP Vecteur de booléens (\fCstd::vector<bool>\fP) rempli dans la fonction \fC\fBgenererDeplacement()\fP\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Une chaine de caractères permettant de déterminer si l'entrée utilisateur est acceptable ou pas\&. La chaîne est définie par l'expression régulière suivante : \fC'Zz'?+'Qq'?+'Ss'?+'Dd'?\fP\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
La fonction \fI\fBne change absolument rien\fP\fP au plateau, ni au jeu\&. Mais cette chaîne sera utilisée de la facon suivante : pour déterminer si l'utilisateur a rentré une demande de deplacement valide, on vérifie que le caractère rentré est présent dans la chaîne de caractères générée ici\&. Si le caractère n'est pas présent, on redemande l'entrée utilisateur au joueur\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgenererDeplacement()\fP & deplacements() 
.RE
.PP

.PP

.SS "\fBCarte\fP jeu::getCarte ()"

.PP
Getter de carte de jeu\&. 
.SS "std::vector<\fBmonstre\fP> jeu::getMonstres ()"

.PP
Getter de vecteur de monstres\&. 
.SS "int jeu::getNbMonstres ()"

.PP
Getter de nombre de monstres\&. 
.SS "\fBpersonnage\fP jeu::getPerso ()"

.PP
Getter de personnage\&. 
.SS "std::vector<int> jeu::orga_entites (std::vector< \fBentite\fP > & vect_entite)"

.PP
Organisation entités\&. Permet de trier les entités (selon leur vitesse)\&. Identifie également les indices de vecteur correspondant à des personnages et les stocke dans un vecteur (pour ciblage par monstres)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvect_entite\fP Vecteur de personnages à trier\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Un vecteur d'entités utilisées pour le combat\&. 
.RE
.PP

.SS "void jeu::quitGame ()"

.PP
Quitte le jeu, sans que l'utilisateur n'ai gagné ni perdu\&. 
.SS "void jeu::setJeuCarte (\fBCarte\fP jeu_map)"

.PP
Setter de carte de jeu\&. 
.SS "void jeu::victoireGame ()"

.PP
Affiche un message de victoire à l'utilisateur\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for The Game from the source code\&.
