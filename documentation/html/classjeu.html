<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Game: jeu Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The Game
   </div>
   <div id="projectbrief">Projet universitaire de génie logiciel commandé par M.Ferreira.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classjeu-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">jeu Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Ceci sera la classe du jeu. Elle contient toutes les entités, la carte, ainsi que les fonctions nécessaires à la partie.  
 <a href="classjeu.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="fonctionsjeu_8h_source.html">fonctionsjeu.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a38513a7bfd0a7ea4e3a5612da2856016"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#a38513a7bfd0a7ea4e3a5612da2856016">jeu</a> ()</td></tr>
<tr class="memdesc:a38513a7bfd0a7ea4e3a5612da2856016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporaire!!  <a href="#a38513a7bfd0a7ea4e3a5612da2856016">More...</a><br /></td></tr>
<tr class="separator:a38513a7bfd0a7ea4e3a5612da2856016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55385a33ef40e0579eb3a3634566c4a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#a55385a33ef40e0579eb3a3634566c4a8">~jeu</a> ()</td></tr>
<tr class="memdesc:a55385a33ef40e0579eb3a3634566c4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructeur par défaut.  <a href="#a55385a33ef40e0579eb3a3634566c4a8">More...</a><br /></td></tr>
<tr class="separator:a55385a33ef40e0579eb3a3634566c4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e46e1fdeb23fc643ed506b0df7f21f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_carte.html">Carte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#ae2e46e1fdeb23fc643ed506b0df7f21f">getCarte</a> ()</td></tr>
<tr class="memdesc:ae2e46e1fdeb23fc643ed506b0df7f21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter de carte de jeu.  <a href="#ae2e46e1fdeb23fc643ed506b0df7f21f">More...</a><br /></td></tr>
<tr class="separator:ae2e46e1fdeb23fc643ed506b0df7f21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd58d1469db0d7595bb732403036823"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpersonnage.html">personnage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#a8bd58d1469db0d7595bb732403036823">getPerso</a> ()</td></tr>
<tr class="memdesc:a8bd58d1469db0d7595bb732403036823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter de personnage.  <a href="#a8bd58d1469db0d7595bb732403036823">More...</a><br /></td></tr>
<tr class="separator:a8bd58d1469db0d7595bb732403036823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e7a7e7b932b935fa73658820038176"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmonstre.html">monstre</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#a22e7a7e7b932b935fa73658820038176">getMonstres</a> ()</td></tr>
<tr class="memdesc:a22e7a7e7b932b935fa73658820038176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter de vecteur de monstres.  <a href="#a22e7a7e7b932b935fa73658820038176">More...</a><br /></td></tr>
<tr class="separator:a22e7a7e7b932b935fa73658820038176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae172cfaf3e5c97e1576dc4069d48ec94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#ae172cfaf3e5c97e1576dc4069d48ec94">getNbMonstres</a> ()</td></tr>
<tr class="memdesc:ae172cfaf3e5c97e1576dc4069d48ec94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter de nombre de monstres.  <a href="#ae172cfaf3e5c97e1576dc4069d48ec94">More...</a><br /></td></tr>
<tr class="separator:ae172cfaf3e5c97e1576dc4069d48ec94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cb5e2a1c7e0925aca09885ff959efc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#a53cb5e2a1c7e0925aca09885ff959efc">setJeuCarte</a> (<a class="el" href="class_carte.html">Carte</a> jeu_map)</td></tr>
<tr class="memdesc:a53cb5e2a1c7e0925aca09885ff959efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter de carte de jeu.  <a href="#a53cb5e2a1c7e0925aca09885ff959efc">More...</a><br /></td></tr>
<tr class="separator:a53cb5e2a1c7e0925aca09885ff959efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852b0a8b2d17f0af120c6798861ef806"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#a852b0a8b2d17f0af120c6798861ef806">deplacement</a> (int &amp;result)</td></tr>
<tr class="memdesc:a852b0a8b2d17f0af120c6798861ef806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de déplacement du joueur sur la carte.  <a href="#a852b0a8b2d17f0af120c6798861ef806">More...</a><br /></td></tr>
<tr class="separator:a852b0a8b2d17f0af120c6798861ef806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834e8a14bd0324c88b2de777a6bdf30f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#a834e8a14bd0324c88b2de777a6bdf30f">afficherJeu</a> (int &amp;result)</td></tr>
<tr class="memdesc:a834e8a14bd0324c88b2de777a6bdf30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction permettant d'afficher la carte, puis de demander un déplacement au joueur.  <a href="#a834e8a14bd0324c88b2de777a6bdf30f">More...</a><br /></td></tr>
<tr class="separator:a834e8a14bd0324c88b2de777a6bdf30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d74300f8d64b3d3cd151e0838ef232"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#a58d74300f8d64b3d3cd151e0838ef232">genererDeplacement</a> (std::vector&lt; bool &gt; &amp;v)</td></tr>
<tr class="memdesc:a58d74300f8d64b3d3cd151e0838ef232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction permettant de générer les déplacements possibles à partir d'une case <code>i,j</code> du plateau de jeu.  <a href="#a58d74300f8d64b3d3cd151e0838ef232">More...</a><br /></td></tr>
<tr class="separator:a58d74300f8d64b3d3cd151e0838ef232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae186e98661e72378c9e659ffcf7a7deb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#ae186e98661e72378c9e659ffcf7a7deb">genererInputAccepte</a> (std::vector&lt; bool &gt; b)</td></tr>
<tr class="memdesc:ae186e98661e72378c9e659ffcf7a7deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction permettant de générer une chaine d'entrées utilisateur acceptables pour le déplacement.  <a href="#ae186e98661e72378c9e659ffcf7a7deb">More...</a><br /></td></tr>
<tr class="separator:ae186e98661e72378c9e659ffcf7a7deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96615463266652e0bdc685c9afe5cfe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#aa96615463266652e0bdc685c9afe5cfe">combat</a> (std::string id_monstre)</td></tr>
<tr class="memdesc:aa96615463266652e0bdc685c9afe5cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module de combat.  <a href="#aa96615463266652e0bdc685c9afe5cfe">More...</a><br /></td></tr>
<tr class="separator:aa96615463266652e0bdc685c9afe5cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a81d9b899b204b4b304821c5bee43b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmonstre.html">monstre</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#af3a81d9b899b204b4b304821c5bee43b">cherche_monstre</a> (std::string id_monstre)</td></tr>
<tr class="memdesc:af3a81d9b899b204b4b304821c5bee43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recherche de monstre.  <a href="#af3a81d9b899b204b4b304821c5bee43b">More...</a><br /></td></tr>
<tr class="separator:af3a81d9b899b204b4b304821c5bee43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77728b27a5a1f4194ac77c414b983f01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#a77728b27a5a1f4194ac77c414b983f01">chargement_entite</a> (std::vector&lt; <a class="el" href="classentite.html">entite</a> &gt; &amp;vect_entite, std::string id_monstre)</td></tr>
<tr class="memdesc:a77728b27a5a1f4194ac77c414b983f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chargement acteurs combat.  <a href="#a77728b27a5a1f4194ac77c414b983f01">More...</a><br /></td></tr>
<tr class="separator:a77728b27a5a1f4194ac77c414b983f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7a155c8adcee663d6aeb98b2dae010"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#afd7a155c8adcee663d6aeb98b2dae010">orga_entites</a> (std::vector&lt; <a class="el" href="classentite.html">entite</a> &gt; &amp;vect_entite)</td></tr>
<tr class="memdesc:afd7a155c8adcee663d6aeb98b2dae010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Organisation entités.  <a href="#afd7a155c8adcee663d6aeb98b2dae010">More...</a><br /></td></tr>
<tr class="separator:afd7a155c8adcee663d6aeb98b2dae010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91981b755a6b0895703d9adf537f0ae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcompetence.html">competence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#a91981b755a6b0895703d9adf537f0ae6">choix_comp</a> (<a class="el" href="classentite.html">entite</a> &amp;indiv)</td></tr>
<tr class="memdesc:a91981b755a6b0895703d9adf537f0ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choix compétence.  <a href="#a91981b755a6b0895703d9adf537f0ae6">More...</a><br /></td></tr>
<tr class="separator:a91981b755a6b0895703d9adf537f0ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ea0cb9e74e6d9b0385720528450f61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentite.html">entite</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#ad9ea0cb9e74e6d9b0385720528450f61">choix_target</a> (<a class="el" href="classcompetence.html">competence</a> comp_util, <a class="el" href="classentite.html">entite</a> &amp;indiv, std::vector&lt; <a class="el" href="classentite.html">entite</a> &gt; &amp;vect_entite, std::vector&lt; int &gt; vect_p)</td></tr>
<tr class="memdesc:ad9ea0cb9e74e6d9b0385720528450f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choix cible.  <a href="#ad9ea0cb9e74e6d9b0385720528450f61">More...</a><br /></td></tr>
<tr class="separator:ad9ea0cb9e74e6d9b0385720528450f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc1f7cfd93bdc33fc9f841ec3f5f80f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#a6bc1f7cfd93bdc33fc9f841ec3f5f80f">appliquer_comp</a> (<a class="el" href="classentite.html">entite</a> indiv, <a class="el" href="classentite.html">entite</a> target, std::vector&lt; <a class="el" href="classentite.html">entite</a> &gt; &amp;vect_entite, <a class="el" href="classcompetence.html">competence</a> comp_util, int &amp;nb_players, int &amp;nb_monsters)</td></tr>
<tr class="memdesc:a6bc1f7cfd93bdc33fc9f841ec3f5f80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appliquer compétence.  <a href="#a6bc1f7cfd93bdc33fc9f841ec3f5f80f">More...</a><br /></td></tr>
<tr class="separator:a6bc1f7cfd93bdc33fc9f841ec3f5f80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110399c4103d3d4391f2007856c3e009"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#a110399c4103d3d4391f2007856c3e009">quitGame</a> ()</td></tr>
<tr class="memdesc:a110399c4103d3d4391f2007856c3e009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quitte le jeu, sans que l'utilisateur n'ai gagné ni perdu.  <a href="#a110399c4103d3d4391f2007856c3e009">More...</a><br /></td></tr>
<tr class="separator:a110399c4103d3d4391f2007856c3e009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c769fff9b23935aef40d6633d774a96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#a7c769fff9b23935aef40d6633d774a96">victoireGame</a> ()</td></tr>
<tr class="memdesc:a7c769fff9b23935aef40d6633d774a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Affiche un message de victoire à l'utilisateur.  <a href="#a7c769fff9b23935aef40d6633d774a96">More...</a><br /></td></tr>
<tr class="separator:a7c769fff9b23935aef40d6633d774a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6163ba51f80fa944374fc1b85021268"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjeu.html#aa6163ba51f80fa944374fc1b85021268">failedGame</a> ()</td></tr>
<tr class="memdesc:aa6163ba51f80fa944374fc1b85021268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Affiche un message de défait au joueur.  <a href="#aa6163ba51f80fa944374fc1b85021268">More...</a><br /></td></tr>
<tr class="separator:aa6163ba51f80fa944374fc1b85021268"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Ceci sera la classe du jeu. Elle contient toutes les entités, la carte, ainsi que les fonctions nécessaires à la partie. </p>
<p>Cette classe contient les fonctions nécessaires au démarrage de la partie, au combat, ainsi que toutes les fonctions intermédiaires nécessaires au bon fonctionnement de celles-ci.</p>
<p>Inclut la librairie io. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a38513a7bfd0a7ea4e3a5612da2856016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38513a7bfd0a7ea4e3a5612da2856016">&#9670;&nbsp;</a></span>jeu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">jeu::jeu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Temporaire!! </p>
<p>Constructeur par défaut sans argument.</p>
<p>Affichage d'un message de bienvenue. Choix du personnage. Choix de la carte. Chargement des monstres.</p>
<dl class="section see"><dt>See also</dt><dd>perso(), carte(), <a class="el" href="classmonstre.html" title="Classe créant un monstre en mémoire. hérite des propriétés ainsi que des attributs de la classe entit...">monstre()</a> </dd></dl>

</div>
</div>
<a id="a55385a33ef40e0579eb3a3634566c4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55385a33ef40e0579eb3a3634566c4a8">&#9670;&nbsp;</a></span>~jeu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">jeu::~jeu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructeur par défaut. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a834e8a14bd0324c88b2de777a6bdf30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834e8a14bd0324c88b2de777a6bdf30f">&#9670;&nbsp;</a></span>afficherJeu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jeu::afficherJeu </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction permettant d'afficher la carte, puis de demander un déplacement au joueur. </p>
<dl class="section note"><dt>Note</dt><dd>Cette fonction est là uniquement pour des fins de tests. La fonctionnalité qu'elle remplit sera remplacée par d'autres méthodes dans la fichier <code>tests/main.cpp</code>. </dd></dl>

</div>
</div>
<a id="a6bc1f7cfd93bdc33fc9f841ec3f5f80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc1f7cfd93bdc33fc9f841ec3f5f80f">&#9670;&nbsp;</a></span>appliquer_comp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int jeu::appliquer_comp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentite.html">entite</a>&#160;</td>
          <td class="paramname"><em>indiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentite.html">entite</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classentite.html">entite</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vect_entite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcompetence.html">competence</a>&#160;</td>
          <td class="paramname"><em>comp_util</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nb_players</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nb_monsters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appliquer compétence. </p>
<p>Permet d'appliquer les effets de la compétence choisie sur la cible choisie. Si la cible meurt, décrémente le compteur de personnages/monstres vivants. Supprime les cibles mortes du vecteur d'entités. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Cible de la compétence. </td></tr>
    <tr><td class="paramname">vect_entite</td><td>Le vecteur duquel on tire la cible de la compétence. </td></tr>
    <tr><td class="paramname">comp_util</td><td>La compétence à utiliser. </td></tr>
    <tr><td class="paramname">nb_players</td><td>Le nombre total de joueurs de la partie. </td></tr>
    <tr><td class="paramname">nb_monsters</td><td>Le nombre de monstres du combat en cours. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Un entier: 1 si tous les monstres sont morts, 0 si tous les joueurs sont morts, 2 sinon. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>enleverVie() </dd></dl>

</div>
</div>
<a id="a77728b27a5a1f4194ac77c414b983f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77728b27a5a1f4194ac77c414b983f01">&#9670;&nbsp;</a></span>chargement_entite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jeu::chargement_entite </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classentite.html">entite</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vect_entite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id_monstre</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chargement acteurs combat. </p>
<p>Permet de charger tous les acteurs du combat dans un vecteur d'entités. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect_entite</td><td>Vecteur où chercher le monstre. </td></tr>
    <tr><td class="paramname">id_monstre</td><td>Identifiant du monstre à charger. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Chargement réussi ou non. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classjeu.html#af3a81d9b899b204b4b304821c5bee43b" title="Recherche de monstre. ">cherche_monstre()</a> </dd></dl>

</div>
</div>
<a id="af3a81d9b899b204b4b304821c5bee43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a81d9b899b204b4b304821c5bee43b">&#9670;&nbsp;</a></span>cherche_monstre()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classmonstre.html">monstre</a>&gt;::iterator jeu::cherche_monstre </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id_monstre</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recherche de monstre. </p>
<p>Permet de trouver l'objet monstre correspondant à la string id trouvée sur une case. Si la valeur renvoyée correspond à la fin du vecteur, le monstre n'a pas été trouvé. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_monstre</td><td>Identifiant du monstre à trouver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Un itérateur correspondant à l'élément du vecteur de monstres concerné. </dd></dl>

</div>
</div>
<a id="a91981b755a6b0895703d9adf537f0ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91981b755a6b0895703d9adf537f0ae6">&#9670;&nbsp;</a></span>choix_comp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcompetence.html">competence</a> jeu::choix_comp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentite.html">entite</a> &amp;&#160;</td>
          <td class="paramname"><em>indiv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choix compétence. </p>
<p>Permet de sélectionner une compétence par input parmi une liste tirée d'un vecteur (spécifique à chaque entité) Vérifie la possibilité du lancer (niveau de mana). Si l'entité est un monstre, le choix est aléatoire. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indiv</td><td>L'entité qui joue actuellement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Une compétence parmi les compétences utilisables. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceio.html#ad045ca63d3481c2da3253a3944df18e4" title="Choix d&#39;un élément unique. ">choix_unique_element()</a> </dd></dl>

</div>
</div>
<a id="ad9ea0cb9e74e6d9b0385720528450f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ea0cb9e74e6d9b0385720528450f61">&#9670;&nbsp;</a></span>choix_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentite.html">entite</a> jeu::choix_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcompetence.html">competence</a>&#160;</td>
          <td class="paramname"><em>comp_util</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentite.html">entite</a> &amp;&#160;</td>
          <td class="paramname"><em>indiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classentite.html">entite</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vect_entite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choix cible. </p>
<p>Permet de choisir une cible parmi une liste tirée d'un vecteur de cibles disponibles. Si l'entité est un monstre, le choix est aléatoire (uniquement parmi les cibles personnages). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp_util</td><td>La compétence à utiliser. </td></tr>
    <tr><td class="paramname">indiv</td><td>L'entité qui joue actuellement. </td></tr>
    <tr><td class="paramname">vect_entite</td><td>Le vecteur duquel on tire la cible de la compétence. </td></tr>
    <tr><td class="paramname">vect_p</td><td>Vecteur permettant d'identifier les personnages parmi toutes les entités. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Une entité, cible de la compétence. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceio.html#ad045ca63d3481c2da3253a3944df18e4" title="Choix d&#39;un élément unique. ">choix_unique_element()</a> </dd></dl>

</div>
</div>
<a id="aa96615463266652e0bdc685c9afe5cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96615463266652e0bdc685c9afe5cfe">&#9670;&nbsp;</a></span>combat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int jeu::combat </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id_monstre</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Module de combat. </p>
<p>Permet de gérer le combat.</p><ul>
<li>Charge les entités (personnages et monstres) contenus dans la case.</li>
<li>Identifie les personnages et leur nombre.</li>
<li>Identifie les monstres et leur nombre.</li>
<li>Pour chaque acteur, choix d'une compétence, puis d'une cible, puis application des effets. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_monstre</td><td>Identifiant du monstre à combattre. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Un entier: 1 si la partie continue, 0 si elle se termine. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classjeu.html#a77728b27a5a1f4194ac77c414b983f01" title="Chargement acteurs combat. ">chargement_entite()</a>, <a class="el" href="classjeu.html#afd7a155c8adcee663d6aeb98b2dae010" title="Organisation entités. ">orga_entites()</a>, <a class="el" href="namespaceio.html#aea8dfd5fea1f29722c77b31ef7b0b940" title="Affichage des entités du combat. ">aff_combat()</a>, <a class="el" href="classjeu.html#a91981b755a6b0895703d9adf537f0ae6" title="Choix compétence. ">choix_comp()</a>, <a class="el" href="classjeu.html#ad9ea0cb9e74e6d9b0385720528450f61" title="Choix cible. ">choix_target()</a>, <a class="el" href="classjeu.html#a6bc1f7cfd93bdc33fc9f841ec3f5f80f" title="Appliquer compétence. ">appliquer_comp()</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a852b0a8b2d17f0af120c6798861ef806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852b0a8b2d17f0af120c6798861ef806">&#9670;&nbsp;</a></span>deplacement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jeu::deplacement </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de déplacement du joueur sur la carte. </p>
<p>Cette fonction permet au joueur de se déplacer sur la carte, en tenant compte des obstacles présents sur ladite carte.</p>
<p>Mode opératoire :</p><ul>
<li>Génère les déplacements possibles grâce à la fonction <code><a class="el" href="classjeu.html#a58d74300f8d64b3d3cd151e0838ef232" title="Fonction permettant de générer les déplacements possibles à partir d&#39;une case i,j du plateau de jeu...">genererDeplacement()</a></code> ;</li>
<li>Génère les entrées utilisateur possibles grâce à la fonction <code><a class="el" href="classjeu.html#ae186e98661e72378c9e659ffcf7a7deb" title="Fonction permettant de générer une chaine d&#39;entrées utilisateur acceptables pour le déplacement...">genererInputAccepte()</a></code> ;</li>
<li>Va chercher la position actuelle du joueur, puis la stocke dans deux entiers (<code>x</code> et <code>y</code>, oui je sais ces noms sont très originaux) ;</li>
<li>Afficher les mouvements possibles au joueur grâce à la fonction <code><a class="el" href="namespaceio.html#ac60b7c3503eb53e69a2adc86368ab633" title="Fonction permettant d&#39;afficher un overlay sur la carte. ">afficherMouvements()</a></code> ;</li>
<li>Demande à l'utilisateur où il souhaiterais aller grâce à la fonction <code><a class="el" href="namespaceio.html#ae9908b55f26f07e78043d7cfad003d22" title="Input. ">de()</a></code></li>
<li>Si le joueur rentre un caractère non compris dans la liste des mouvements possibles :<ul>
<li>On ré-affiche les mouvements possibles avec <code><a class="el" href="namespaceio.html#ac60b7c3503eb53e69a2adc86368ab633" title="Fonction permettant d&#39;afficher un overlay sur la carte. ">afficherMouvements()</a></code>, cette fois-ci avec un message d'erreur en plus.</li>
<li>On re-demande son choix pour le mouvement grâce à la fonction <code><a class="el" href="namespaceio.html#ae9908b55f26f07e78043d7cfad003d22" title="Input. ">de()</a></code></li>
</ul>
</li>
<li>On change les coordonnées des entiers <code>x</code> et <code>y</code> en accord avec la demande de l'utilisateur dans un <code>switch</code>.</li>
<li>On met à jour l'affichage de la carte grâce à la fonction <code><a class="el" href="namespaceio.html#ae9438bfe8b2631be82b0f4d644358545" title="Met à jour l&#39;affichage de la carte. ">updateMap()</a></code> <dl class="section post"><dt>Postcondition</dt><dd>La position du joueur aura changé. La paire d'entiers <code>currentPlayerPosition</code> sera donc mise à jour (grâce à <code><a class="el" href="namespaceio.html#ae9438bfe8b2631be82b0f4d644358545" title="Met à jour l&#39;affichage de la carte. ">updateMap()</a></code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceio.html#ac60b7c3503eb53e69a2adc86368ab633" title="Fonction permettant d&#39;afficher un overlay sur la carte. ">afficherMouvements()</a>, <a class="el" href="classjeu.html#a58d74300f8d64b3d3cd151e0838ef232" title="Fonction permettant de générer les déplacements possibles à partir d&#39;une case i,j du plateau de jeu...">genererDeplacement()</a>, <a class="el" href="classjeu.html#ae186e98661e72378c9e659ffcf7a7deb" title="Fonction permettant de générer une chaine d&#39;entrées utilisateur acceptables pour le déplacement...">genererInputAccepte()</a>, <a class="el" href="namespaceio.html#ae9908b55f26f07e78043d7cfad003d22" title="Input. ">de()</a> &amp; <a class="el" href="namespaceio.html#ae9438bfe8b2631be82b0f4d644358545" title="Met à jour l&#39;affichage de la carte. ">io::updateMap()</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a id="aa6163ba51f80fa944374fc1b85021268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6163ba51f80fa944374fc1b85021268">&#9670;&nbsp;</a></span>failedGame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jeu::failedGame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Affiche un message de défait au joueur. </p>

</div>
</div>
<a id="a58d74300f8d64b3d3cd151e0838ef232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d74300f8d64b3d3cd151e0838ef232">&#9670;&nbsp;</a></span>genererDeplacement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string jeu::genererDeplacement </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction permettant de générer les déplacements possibles à partir d'une case <code>i,j</code> du plateau de jeu. </p>
<p>Cette fonction permet de générer la chaîne de caractères qui affiche les déplacements disponibles au joueur à partir de la case où il se trouve. Mode opératoire :</p><ul>
<li>On prends les coordonnées actuelles du joueur, que l'on met dans deux entiers créativement appelés <code>x</code> et <code>y</code>.</li>
<li>On prends la taille de la carte du jeu grâce à la fonction <code>carte::getTaille()</code>. La taille du plateau nous sert à déterminer si une case existe, enlevant ainsi un peu de temps de calcul lors de l'analyse des cases voisines à celle où se trouve le joueur.</li>
<li>On crée une chaîne de caractères. Cette chaîne servira à stocker les déplacements possibles à afficher par la suite au joueur.</li>
<li>On vérifie les cases autour du joueur en vérifiant leurs indices et leur contenu (grâce à la fonction <code>carte::caseAccessible()</code>)</li>
<li>Si la case au dessus du joueur est libre, alors :<ul>
<li>On ajoute <code>Z - Haut</code> à la chaîne de caractères</li>
<li>On met à 1 le booléen permettant de savoir si la case est accessible ou non.</li>
</ul>
</li>
<li>Si la case à la gauche du joueur est libre, alors :<ul>
<li>On ajoute <code>Q - Gauche</code> à la chaîne de caractères</li>
<li>On met à 1 le booléen permettant de savoir si la case est accessible ou non.</li>
</ul>
</li>
<li>Si la case en dessous du joueur est libre, alors :<ul>
<li>On ajoute <code>S - Bas</code> à la chaîne de caractères</li>
<li>On met à 1 le booléen permettant de savoir si la case est accessible ou non.</li>
</ul>
</li>
<li>Si la case à la droite du joueur est libre, alors :<ul>
<li>On ajoute <code>D - Droite</code> à la chaîne de caractères</li>
<li>On met à 1 le booléen permettant de savoir si la case est accessible ou non.</li>
</ul>
</li>
<li>On retourne la châine de caractères générée. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vecteur de booléens (<code>std::vector&lt;bool&gt;</code>) permettant de savoir quelles cases sont accessibles aux alentours de la case où se trouve le joueur. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Une châine de caractères à afficher au joueur pour qu'il puisse savoir où il peut aller. La chaine est définie par l'expression régulière suivante : <code>"|"+(" Z - Haut |")?+(" Q - Gauche |")?+(" S - Bas |")?+(" D - Droite |")?</code> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>La fonction <em><b>ne change absolument rien</b></em> au plateau, ni au jeu. Toutes les données générées pour l'analyse des voisins de la case ont une portée locale. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classjeu.html#ae186e98661e72378c9e659ffcf7a7deb" title="Fonction permettant de générer une chaine d&#39;entrées utilisateur acceptables pour le déplacement...">genererInputAccepte()</a>, <a class="el" href="classjeu.html#a852b0a8b2d17f0af120c6798861ef806" title="Fonction de déplacement du joueur sur la carte. ">deplacement()</a>, carte::caseAccessible() &amp; carte::getTaille() </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ae186e98661e72378c9e659ffcf7a7deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae186e98661e72378c9e659ffcf7a7deb">&#9670;&nbsp;</a></span>genererInputAccepte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string jeu::genererInputAccepte </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction permettant de générer une chaine d'entrées utilisateur acceptables pour le déplacement. </p>
<p>Cette fonction permet de générer la chaîne de caractères qui sera analysée pour accepter ou non un déplacement demandé par le joueur à partir de la case où il se trouve.</p>
<p>Mode opératoire :</p><ul>
<li>Crée une chaîne de caractères (<code>std::string</code>) qui contiendra les caractères acceptés lors de l'entrée utilisateur dans la fonction <code><a class="el" href="classjeu.html#a852b0a8b2d17f0af120c6798861ef806" title="Fonction de déplacement du joueur sur la carte. ">deplacement()</a></code>.</li>
<li>Lit le vecteur de booléens rempli dans la fonction <code><a class="el" href="classjeu.html#a58d74300f8d64b3d3cd151e0838ef232" title="Fonction permettant de générer les déplacements possibles à partir d&#39;une case i,j du plateau de jeu...">genererDeplacement()</a></code> :<ul>
<li>Si le premier booléen est à 1 : on ajoute "Zz" à la chaîne (l'utilisateur pourra donc appuyer sur 'Z' ou 'z' et se déplacer)</li>
<li>Si le second booléen est à 1 : on ajoute "Qq" à la chaîne (l'utilisateur pourra donc appuyer sur 'Q' ou 'q' et se déplacer)</li>
<li>Si le troisième booléen est à 1 : on ajoute "Ss" à la chaîne (l'utilisateur pourra donc appuyer sur 'S' ou 's' et se déplacer)</li>
<li>Si le quatrième booléen est à 1 : on ajoute "Dd" à la chaîne (l'utilisateur pourra donc appuyer sur 'D' ou 'd' et se déplacer)</li>
</ul>
</li>
<li>Retourne la chaîne de caractères. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Vecteur de booléens (<code>std::vector&lt;bool&gt;</code>) rempli dans la fonction <code><a class="el" href="classjeu.html#a58d74300f8d64b3d3cd151e0838ef232" title="Fonction permettant de générer les déplacements possibles à partir d&#39;une case i,j du plateau de jeu...">genererDeplacement()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Une chaine de caractères permettant de déterminer si l'entrée utilisateur est acceptable ou pas. La chaîne est définie par l'expression régulière suivante : <code>"Zz"?+"Qq"?+"Ss"?+"Dd"?</code>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>La fonction <em><b>ne change absolument rien</b></em> au plateau, ni au jeu. Mais cette chaîne sera utilisée de la facon suivante : pour déterminer si l'utilisateur a rentré une demande de deplacement valide, on vérifie que le caractère rentré est présent dans la chaîne de caractères générée ici. Si le caractère n'est pas présent, on redemande l'entrée utilisateur au joueur. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classjeu.html#a58d74300f8d64b3d3cd151e0838ef232" title="Fonction permettant de générer les déplacements possibles à partir d&#39;une case i,j du plateau de jeu...">genererDeplacement()</a> &amp; deplacements() </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ae2e46e1fdeb23fc643ed506b0df7f21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e46e1fdeb23fc643ed506b0df7f21f">&#9670;&nbsp;</a></span>getCarte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_carte.html">Carte</a> jeu::getCarte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter de carte de jeu. </p>

</div>
</div>
<a id="a22e7a7e7b932b935fa73658820038176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e7a7e7b932b935fa73658820038176">&#9670;&nbsp;</a></span>getMonstres()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classmonstre.html">monstre</a>&gt; jeu::getMonstres </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter de vecteur de monstres. </p>

</div>
</div>
<a id="ae172cfaf3e5c97e1576dc4069d48ec94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae172cfaf3e5c97e1576dc4069d48ec94">&#9670;&nbsp;</a></span>getNbMonstres()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int jeu::getNbMonstres </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter de nombre de monstres. </p>

</div>
</div>
<a id="a8bd58d1469db0d7595bb732403036823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd58d1469db0d7595bb732403036823">&#9670;&nbsp;</a></span>getPerso()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpersonnage.html">personnage</a> jeu::getPerso </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter de personnage. </p>

</div>
</div>
<a id="afd7a155c8adcee663d6aeb98b2dae010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7a155c8adcee663d6aeb98b2dae010">&#9670;&nbsp;</a></span>orga_entites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; jeu::orga_entites </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classentite.html">entite</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vect_entite</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Organisation entités. </p>
<p>Permet de trier les entités (selon leur vitesse). Identifie également les indices de vecteur correspondant à des personnages et les stocke dans un vecteur (pour ciblage par monstres). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect_entite</td><td>Vecteur de personnages à trier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Un vecteur d'entités utilisées pour le combat. </dd></dl>

</div>
</div>
<a id="a110399c4103d3d4391f2007856c3e009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110399c4103d3d4391f2007856c3e009">&#9670;&nbsp;</a></span>quitGame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jeu::quitGame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quitte le jeu, sans que l'utilisateur n'ai gagné ni perdu. </p>

</div>
</div>
<a id="a53cb5e2a1c7e0925aca09885ff959efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cb5e2a1c7e0925aca09885ff959efc">&#9670;&nbsp;</a></span>setJeuCarte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jeu::setJeuCarte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_carte.html">Carte</a>&#160;</td>
          <td class="paramname"><em>jeu_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setter de carte de jeu. </p>

</div>
</div>
<a id="a7c769fff9b23935aef40d6633d774a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c769fff9b23935aef40d6633d774a96">&#9670;&nbsp;</a></span>victoireGame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jeu::victoireGame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Affiche un message de victoire à l'utilisateur. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/thibault/GitHub/CERI_software_engineering_game_1/headers/<a class="el" href="fonctionsjeu_8h_source.html">fonctionsjeu.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
